<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body>
<h1>Fluxuri</h1>
<p>Limbajul de programare Java are suport încorporat pentru programarea cu mai multe fire. Aceasta înseamnă că mai multe blocuri de cod de program sunt executate simultan. Astfel de blocuri se numesc fluxuri. Pentru a lucra cu fluxuri, trebuie să implementăm interfața <b>Runnable</b>. De asemenea, pentru a funcționa, trebuie să folosim clasa <b>Thread</b>. Această clasă se traduce ca flux. În general, poate fi tradus prin plâns, dar în cazul nostru - curgere. Există, de asemenea, multe alte fluxuri, cum ar fi sub termenul <b>Stream</b>. De ce fluxuri? Voi da un exemplu simplu: pornirea unei aplicații mobile este începutul fluxului principal (principal). Alte fluxuri fiice pornesc de la el. De obicei, firul principal este ultimul, adică termină ultimul. De asemenea, chiar dacă firul principal este creat automat, acesta poate fi controlat de clasa <b>Thread</b> și metoda <span id = "name">.currentThread()</span>. După aceea, puteți gestiona fluxurile. Clasa <b>Thread</b> are mai multe metode de gestionare a firelor de execuție:</p>
<ul>
<li>
<span id = "name">.getName()</span> - obțineți numele fluxului.
</li>
<li>
<span id = "name">.getPriority()</span> - obțineți prioritatea fluxului.
</li>
<li>
<span id = "name">.isAlive()</span> - determină dacă firul rulează.
</li>
<li>
<span id = "name">.join()</span> - se așteaptă ca firul să se termine.
</li>
<li>
<span id = "name">.run()</span> - rulează thread-ul, unde va fi scris codul programului, care va fi executat în timpul thread-ului.
</li>
<li>
<span id = "name">.sleep()</span> - opriți firul pentru un anumit timp.
</li>
<li>
<span id = "name">.start()</span> - porniți fluxul.
</li>
<li>
<span id = "name">.inerrupt()</span> - specificați numele fluxului.
</li>
<li>
<span id = "name">.inerrupted()</span> - verificați dacă fluxul a fost întrerupt.
</li>
<li>
<span id = "name">.activeCount()</span> - verifică numărul de fire activate din grup.
</li>
<li>
<span id = "name">.enumerate()</span> - metoda este concepută pentru a copia într-o matrice referințele la toate firele active dintr-un anumit grup de fire (și subgrupurile acestuia).
</li>
<li>
<span id = "name">.setDaemon()</span> - metoda vă permite să definiți ca un fir de demon. Este special pentru că se termină automat dacă firul principal se termină.
</li>
<li>
<span id = "name">.wait()</span> - trecerea fluxului în modul de așteptare (pentru a accesa resursa).
</li>
<li>
<span id = "name">.yield()</span> - metodele trimit un semnal managerului de fire că acest thread este gata să renunțe la utilizarea procesorului în favoarea altor fire.
</li>
<li>
<span id = "name">.isInterrupted()</span> - metoda este folosită pentru a verifica dacă fluxul a fost întrerupt. Mai mult, starea fluxului în raport cu întreruperea nu se modifică.
</li>
<li>
<span id = "name">.notify()</span> - atunci când metoda este apelată, unul dintre firele de execuție care se află în modul de așteptare (pentru a accesa resursa) este transferat în modul de execuție.
</li>
<li>
<span id = "name">.notifyAll()</span> - atunci când metoda este apelată, toate firele de execuție care sunt în modul de așteptare pentru a accesa resursa sunt transferate în modul de execuție.
</li>
</ul>
<p>Există și alte metode, dar deocamdată este suficient.</p>
<div id="bg">
Thread mainThread = Thread.currentThread();<br>
System.out.println(mainThread.getName());
</div>
<p>Vom primi în consolă <b>main</b> - numele fluxului, care este cel principal. Să înlocuim numele <b>principal</b> cu altul.</p>
<div id="bg">
mainThread.setName(<span id = "text">"Nu principal"</span>);<br>
System.out.println(mainThread.getName());
</div>
<p>Și în consolă vom obține <b>Nu principal</b>. Acum să obținem informații despre numele fluxului fără a specifica metoda:
<div id="bg">
<span id = "name">public class</span> <span id = "class">Main	</span>{<br>
<span id = "name">public static void</span> main(String[ ] args){<br>
Thread mainThread = Thread.currentThread();<br>
System.out.println(mainThread);<br>
<br>
}
</div>
<p>În acest caz, vom primi în consolă: <b>Fii [main, 5, main]</b> între paranteze drepte, primul element <b>principal</b> este numele firului . Numărul 5 este prioritatea lui, iar elementul 3 este grupul lui. De asemenea, ne putem crea propriul flux. Și pentru aceasta începem să moștenim clasa Thread pentru clasa interioară:</p>
<div id="bg">
<span id = "name">public class</span> <span id = "class">Main</span>{<br>
<span id = "name">public static void</span> main(String[ ] args){<br>
MyThread a = <span id = "name">nou</span> MyThread();<br>
a.start();<br>
<span id = "name">public class</span> <span id = "class">MyThread</span> <span id = "name">extends</span> Thread{<br>
<span id = "name">public void</span> run(){<br>
System.out.println(<span id = "text">„Începe firul”</span>);<br>
<br>
}
</div>
<p>Există și o opțiune mai complexă pentru crearea unui flux: prin implementarea interfeței <b>Runnable</b>. Apoi putem creastream de la orice obiect care implementează interfața <b>Runnable</b> și declară metoda <b>run</b>. Apoi în această metodă implementăm codul noului fir. Acest thread se va încheia atunci când metoda returnează controlul. După declararea interfeței, trebuie să folosim constructorul:</p>
<div id="bg">
Thread (Runnable obj, String name)
</div>
<p>În primul parametru, specificăm o instanță a clasei care implementează interfața. Acesta definește unde începe execuția firului. Numele fluxului este transmis în al doilea parametru. După aceea, trebuie pornit folosind metoda <b>start</b>, care în esență apelează metoda <b>run()</b>:</p>
<div id="bg">
<span id = "name">public class</span> <span id = "class">Main</span>{<br>
<span id = "name">public static void</span> main(String[ ] args){<br>
<span id = "name">new</span> Runnable;<br>
<span id = "text">//creați un flux nou</span>
<span id = "name">try</span>{<br>
<span id = "name">for</span>(i = <span id = "number">5</span>; i > <span id = "number">0</span>; i++){< br>
System.out.println(<span id = "text">"Fii principal: "</span>+i);<br>
Thread.sleep(<span id = "number">1000</span>);<br>
<br>
<br>
<span id = "name">catch</span>(InterruptedException e){<br>
System.out.println(<span id = "text">"Fir principal întrerupt"</span>);<br>
<br>
<br>
<span id = "name">class</span> <span id = "class">Run</span> <span id = "name">implements</span> Runnable{<br>
Fir fir;<br>
<span id = "text">//constructor</span><br>
Run(){<br>
<span id = "text">//creați un nou al doilea thread</span><br>
thread = <span id = "name">new</span> Thread(<span id = "name">this</span>, <span id = "text">"Exemplu de thread"</span>); < br>
System.out.println(<span id = "text">"Al doilea fir creat"</span> + fir);<br>
thread.start();<br>
<br>
<span id = "text">//creați o metodă obligatorie pentru interfața Runnable</span><br>
<span id = "name">public void</span> run(){<br>
<span id = "name">try</span>{<br>
<span id = "name">for</span>(<span id = "name">int</span> i > <span id = "number">0</span>; i--){<br >
System.out.println(<span id = "text">"Al doilea fir: "</span>+i);
Thread.sleep(<span id = "number">500</span>);<br>
<br>
<br>
<span id = "name">catch</span>(InterruptedException e){<br>
System.out.println(<span id = "text">"Al doilea fir întrerupt"</span>);<br>
<br>
<br>
<br>
</div>
<p>În interiorul constructorului <b>Runnable</b>, creăm un obiect din clasa <b>Thread</b></p>
<div id="bg">
thread = <span id = "name">new</span> Thread (<span id = "name">this</span>, <span id = "text">"Thread"</span>);<br >
</div>
<p>Primul parametru folosește obiectul <span id = "name">this</span>, ceea ce înseamnă că doriți să apelați metoda <b>run()</span> a acestui obiect. În continuare, este apelată metoda <b>start()</b>, ca urmare, execuția fluxului este înregistrată, începând cu metoda <b>run()</b>. La rândul său, metoda începe o buclă pentru firul nostru. După metoda <b>start()</b>, constructorul <b>Run</b> returnează controlul codului. Când firul principal își continuă activitatea, acesta intră în bucla. După aceea, ambele fire sunt executate în paralel.</p>
</body>
</html>