<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body>
<h1>native методи</h1>
<div id = "bg">
<span id = "key">public native int</span> <span id = "class">hashCode</span>();
</div>
<p>Це метод класу <b>Object</b><br>
<span id = "key">native</span> - Java Native Interface (JNI) - механізм для запуску коду під керуванням віртуальної машини Java (JVM), який написаний нативними мовами програмування, як от <b>С</b> або <b>С++</b>, Go, PHP, C#, Visual Basic, Python і скомпільованих у вигляді динамічних бібліотек(як <b>.dll</b> - Windows, <b>.so</b> - Android) дозволяє не використовувати статичне зв'язування. Простими словами це річ, яка допоможе працювати з бібліотеками різних мов. Щоб скачати її треба прописати код<br>
В цьому розділі ми поговоримо про те, як створити нативний метод на C</p>
<div id = "bg">
<span id = "key">class</span> <span id = "class">NativeMethod</span> {<br>
    <span id = "key">public static native void</span> greeting();<br>
}
</div>
<p>Скомплюємо наш файл: NativeMethod.class з використанням команди javac:<br>
<div id = "bg">
javac NativeMethod.java
</div>
Тепер у нас є файл NativeMethod.class, який являє собою скопільованим файлом.<br>
Після цього, треба створити заголовковий файл (header  file) мови С: <b>NativeMethod.h</b>. Це робиться автоматично за допомгою команди:
<div id = "bg">
javac -h . NativeMethod.java
</div>
Тепер розберемося:
-h - аргумент, який компілює заголовковий файл. <br>
. - аргумент, який указує поточне місце в папці, де буде створений заголовковий файл<br>
NativeMethod.java - клас, з якого треба перетворити заголовковий файл.<br>
Тепер у нас є файл: <b>NativeMethod.h</b>, код якого такий:
<div id = "bg">
<span id = "text">/* DO NOT EDIT THIS FILE - it is machine generated */</span><br>
<span id = "key">#include</span> &lt;jni.h><br>
<span id = "text">/* Header for class NativeMethod */</span><br><br>

<span id = "key">#ifndef</span> _Included_NativeMethod<br>
<span id = "key">#define</span> _Included_NativeMethod<br>
<span id = "key">#ifdef</span> __cplusplus<br>
<span id = "key">extern</span> <span id = "text">"C"</span> {<br>
<span id = "key">#endif</span><br>
<span id = "text">/*<br>
 * Class:     NativeMethod<br>
 * Method:    greeting<br>
 * Signature: ()V<br>
 */</span><br>
JNIEXPORT <span id = "key">void</span> JNICALL Java_NativeMethod_greeting<br>
  (JNIEnv *, jclass);<br><br>

<span id = "key">#ifdef</span> __cplusplus<br>
}<br>
<span id = "key">#endif</span><br>
<span id = "key">#endif</span><br>
</div>
Створимо тепер С файл: <b>NativeMethod.c</b>, відкриємо новостворений, пустий файл і вставимо пару рядків з заголовкового файлу:
<div id = "bg">
JNIEXPORT <span id = "key">void</span> JNICALL Java_NativeMethod_greeting<br>
  (JNIEnv *, jclass);
</div>
Зробимо ці два рядки - одним рядком (просто прибрати символ enter :D):
<div id = "bg">
JNIEXPORT <span id = "key">void</span> JNICALL Java_NativeMethod_greeting(JNIEnv *, jclass);
</div>
Тепер давайте обговоримо що воно таке оце ось...<br>
<b>JNIEXPORT</b>: Це макрос, який вказує на те, що наступна функція повинна бути експортована (доступна для використання з інших файлів) з бібліотеки, яка буде згенерована після компіляції вашого C/C++ коду.<br>
<b>void</b>: Це тип повернення методу. У цьому випадку метод не повертає жодного значення.<br>
<b>JNICALL</b>: Це макрос, який вказує на те, що наступні параметри функції є відповідною сигнатурою для Java Native Interface (JNI).</br>
<b>Java_NativeMethod_greeting</b>: Це повна сигнатура нативного методу, яка відображає повну кваліфіковану назву класу і методу в Java. У цьому випадку, метод greeting з класу NativeMethod.<br>
<b>(JNIEnv *, jclass)</b>: Це параметри методу:<br>
<b>JNIEnv *</b>: Це вказівник на структуру JNIEnv, яка представляє собою інтерфейс до Java Native Interface. Цей параметр дозволяє нам взаємодіяти з Java з нативного коду.</br>
<b>jclass</b>: Це тип, який представляє Java клас в нативному коді. Він вказує на клас, в якому знаходиться нативний метод. У цьому випадку, це клас NativeMethod.</br>
Отже, цей рядок говорить нам, що існує нативний метод greeting в класі NativeMethod, який не приймає жодних параметрів і не повертає значення.<br>
<br>
Повернімося до нашого <b>NativeMethod.c</b><br>
Першим чином, ми маємо підключити стандартну бібліотеку для С:
<div id = "bg">
<span id = "key">#include</span> &lt;stdio.h>
</div>
Також, ми маємо додати заголовковий файл для того щоб С-файл міг працюват з кодом в Java:
<div id = "bg">
<span id = "key">#include</span> <span id = "text">"NativeMethod.h"</span>
</div>
Тепер ми маємо ось такий файл:
<div id = "bg">
<span id = "key">#include</span> &lt;studio.h><br>
<span id = "key">#include</span> <span id = "text">"NativeMethod.h"</span><br>
JNIEXPORT <span id = "key">void</span> JNICALL Java_NativeMethod_greeting(JNIEnv *, jclass);
</div>
Але нам треба, щоб наш код щось робив, тож тепер ми ще раз видозмінемо його:
<div id = "bg">
<span id = "key">#include</span> &lt;studio.h><br>
<span id = "key">#include</span> <span id = "text">"NativeMethod.h"</span><br>
JNIEXPORT <span id = "key">void</span> JNICALL Java_NativeMethod_greeting(JNIEnv *, jclass){<br>
    printf(<span id = "text">hello from C! \n"</span>);<br>
	}
</div>
Тепер скомпілюємо за допомгою компілятора gcc:
<div id = "bg">
gcc -fPIC -I"C:\Users\Ukraine\.jdks\corretto-16.0.2\include" -I"C:\Users\Ukraine\.jdks\corretto-16.0.2\include\win32" -shared -o lib.so nativemethod.c
</div>
Роз'яснюємо:<br>
<b>-fPIC</b> означає "Position Independent Code". Ця опція вказує компілятору генерувати код, який є незалежним від конкретної адреси пам'яті. Зазвичай ця опція вимагається при створенні об'єднаних бібліотек (shared libraries) для систем, які підтримують використання розміщення коду на динамічних адресах (таких як Linux) <br>
<b>-I</b> ця опція додає директорію до списку шляхів пошуку заголовочних файлів. Ми використовуємо коли ми компілюємо код, який включає заголовочні файли, ви повинні вказати компілятору, де він може знайти ці файли. Опція -I дозволяє нам вказати ці директорії. В вашому випадку ми вказуємо шляхи до заголовочних файлів для JDK.<br>
<b>"C:\Users\Ukraine\.jdks\corretto-16.0.2\include"</b> - шлях (для ОС Windows), де знаходиться версія Java. В моєму випадку - corretto-16.0.2 ам цей шлях отримує заголовковий файл jni.h. <br>
<b>"C:\Users\Ukraine\.jdks\corretto-16.0.2\include\win32"</b> - шлях, де знаходиться інший заголовковий файл: jni_md.<br>
<b>-shared</b> - вказує компілятору створити об'єднану бібліотеку з вашого коду. Це означає, що код, який ви компілюєте, буде згенерований як динамічна бібліотека, яку можна завантажити під час виконання програми.<br>
<b>-o lib.so</b> - вказує, що вихідний файл повинен мати ім'я lib.so.<br><br>

Тепер у нас є все, що потрібно. Але нам залишилось - написати код на Java:
<div id = "bg">
<span id = "key">public class</span> <span id = "class">Main</span> {<br>
    <span id = "key">public static void</span> </span id = "class">main</span>(String[] args) {<br>
        NativeMethod.greeting();<br>
    }<br>
	<br>
        <br>
    <span id = "key">static</span>{<br>
        System.load(<br><span id = "text">"C:\\Users\\Ukraine\\Desktop\\javaTest\\lib.so"</span><br>);<br>
    }<br>
    <br>
}
</div>
Тепер нам треба скомпілювати цей Java-файл в .class:
<div id = "bg">
javac Main.java
</div>
Тепер треба зліпити все це в одну річ. Ось наша свята команда:
<div id = "bg">
java -Djava.library.path=. Main
</div>
Тепер розберемося в цьому:<br>
<b>java</b>: це команда для запуску віртуальної машини Java (JVM).<br>
<b>-Djava.library.path=</b>: це системна властивість для вказання шляху до директорії, де знаходяться нативні бібліотеки (наприклад, lib.so). У цьому випадку<br>
<b>.</b> вказує на поточну папку, тобто JVM буде шукати нативну бібліотеку у поточній директорії.<br>
<b>Main</b>: це повна назва головного класу нашої програми, який містить метод main(String[] args). JVM запускає цей метод при запуску програми.<br>
<br>
Запустивши код, ми отримаємо помилку. Є 2 типи помилок:
1. Лінкування<br>
2. Помилка пов'язана з тим, що ми використовуємо юкусь IDE, а не cmd.<br>
<br>
Саме зараз - помилка лінкування. Де? В С коді:
<div id="bg">
<span id="key">#include</span> &lt;studio.h&gt;<br>
<span id="key">#include</span> <span id="text">"NativeMethod.h"</span><br>
JNIEXPORT <span id="key">void</span> JNICALL Java_NativeMethod_greeting(JNIEnv *, jclass){<br>
    printf(<span id="text">hello from C! \n"</span>);<br>
	}
</div>
Де?<br><br>
Ми ортимали помилку в аргументах. Наш правильний запис повинен бути такий:
<div id="bg">
<span id="key">#include</span> &lt;studio.h&gt;<br>
<span id="key">#include</span> <span id="text">"NativeMethod.h"</span><br>
JNIEXPORT <span id="key">void</span> JNICALL Java_NativeMethod_greeting(JNIEnv *env, jclass thebestclassever){<br>
    printf(<span id="text">hello from C! \n"</span>);<br>
	}
</div>
Тобто ми не присвоїли значень до посилання на наш нативний метод. Ось і все.<br>
Тепер знову все по новій ми запустимо:
<div id="bg">
gcc -fPIC -I"C:\Users\Ukraine\.jdks\corretto-16.0.2\include" -I"C:\Users\Ukraine\.jdks\corretto-16.0.2\include\win32" -shared -o lib.so nativemethod.c
<br>
javac Main.java<br>
java -Djava.library.path=. Main
</div>
Запустивши код знову, ми отрамємо в консолі:
<div>
hello from C!
</div>
<br>
<br>
<h4>Деякі моменти</h4>
Проблеми можуть виникати, якщо ми працюжмо в проєкті, тобто всюди маємо ключове слово <span id = "key">package</span> або ж використання Maven / Gradle. Рекомендую не робити ці файли в проекти, а як окремі файли, незалежні один від одного.<br>
Також, повторимо ще раз, що найкраще запускати код з cmd, а не з якихось ide, бо шанс отрмати помилку буде мінімальний
</body>
</html>
